<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>5 Card Draw Poker</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #1e293b;
            color: white;
            overflow: hidden;
        }

        #debug {
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(0,0,0,0.7);
            padding: 5px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 100;
        }

        .game-container {
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .game-header {
            background-color: #0f2937;
            color: #f8c471;
            padding: 10px;
            text-align: center;
            font-size: 20px;
            border-bottom: 2px solid #713f12;
        }

        .table-area {
            flex: 1;
            position: relative;
            margin: 20px;
            background-color: #15803d;
            border-radius: 50%;
            border: 10px solid #713f12;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: inset 0 0 30px rgba(0,0,0,0.5);
        }

        .table-center {
            text-align: center;
        }

        .pot {
            font-size: 22px;
            font-weight: bold;
            color: #fcd34d;
            margin-bottom: 15px;
            text-shadow: 1px 1px 2px #000;
        }

        .player-positions {
            position: absolute;
            width: 100%;
            height: 100%;
        }

        .player-spot {
            position: absolute;
            width: 120px;
            padding: 8px;
            background-color: rgba(0,0,0,0.6);
            border-radius: 5px;
            text-align: center;
        }

        /* Player positions around the table */
        .player-spot:nth-child(1), 
        .player-spot:nth-child(2), 
        .player-spot:nth-child(3), 
        .player-spot:nth-child(4), 
        .player-spot:nth-child(5) {
            position: absolute;
        }
        
        .player-spot {
            position: absolute;
            width: 120px;
            padding: 8px;
            background-color: rgba(0,0,0,0.6);
            border-radius: 5px;
            text-align: center;
        }
        
        .current-player {
            background-color: rgba(0,0,0,0.8);
            border: 2px solid #f8c471;
        }

        .player-turn {
            background-color: rgba(61, 12, 82, 0.8);
            box-shadow: 0 0 15px #9333ea;
            border: 2px solid #9333ea;
            animation: pulse-turn 2s infinite;
        }

        @keyframes pulse-turn {
            0% { box-shadow: 0 0 15px #9333ea; }
            50% { box-shadow: 0 0 25px #9333ea; }
            100% { box-shadow: 0 0 15px #9333ea; }
        }

        .player-name {
            font-weight: bold;
            color: #f8c471;
            margin-bottom: 5px;
            word-break: break-word;
        }

        .player-chips {
            font-size: 14px;
            color: #bdc3c7;
        }

        .player-cards {
            display: flex;
            justify-content: center;
            gap: 5px;
            margin-top: 5px;
        }

        /* Add to the style section in five_card.html */
        .card {
            display: inline-block;
            width: 35px;
            height: 50px;
            margin: 0 2px;
            background-color: #fff;
            border: 1px solid #333;
            border-radius: 4px;
            text-align: center;
            line-height: 50px;
            font-weight: bold;
            font-size: 14px;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.5);
            position: relative;
        }

        .card.facedown {
            background: linear-gradient(135deg, #1e40af 25%, #1e3a8a 25%, #1e3a8a 50%, #1e40af 50%, #1e40af 75%, #1e3a8a 75%);
            background-size: 20px 20px;
            color: transparent;
        }

        .card-placeholder {
            background-color: rgba(255, 255, 255, 0.2);
            border: 1px dashed rgba(255, 255, 255, 0.5);
            color: transparent;
        }

        .red-card {
            color: #cc0000;
        }

        .black-card {
            color: #000;
        }

        .folded-indicator {
            display: block;
            color: #ff4444;
            font-weight: bold;
            text-transform: uppercase;
            font-size: 14px;
        }

        .player-folded {
            opacity: 0.7;
        }

        /* Add style for the player's own cards for better visibility */
        .current-player .card:not(.facedown) {
            transform: translateY(-5px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            border: 2px solid #f8c471;
        }

        .game-status {
            position: absolute;
            bottom: 15px;
            left: 15px;
            padding: 8px 12px;
            background-color: rgba(0,0,0,0.7);
            border-radius: 4px;
        }

        /* Add this to your existing styles */
        .card.dealing {
            animation: dealCard 0.3s ease-out;
            transform-origin: center center;
        }

        @keyframes dealCard {
            0% {
                opacity: 0;
                transform: translateY(-50px) scale(0.8);
            }
            100% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        /* Add this to your existing styles */
        .wallet-decrease {
            color: #ff4444;
            animation: flash-decrease 0.8s;
        }

        .wallet-increase {
            color: #44ff44;
            animation: flash-increase 0.8s;
        }

        @keyframes flash-decrease {
            0%, 100% { color: #bdc3c7; }
            50% { color: #ff4444; }
        }

        @keyframes flash-increase {
            0%, 100% { color: #bdc3c7; }
            50% { color: #44ff44; }
        }

        /* Add these to your existing styles */
        .card-selection-container {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
            z-index: 10;
            box-shadow: 0 0 20px rgba(0,0,0,0.7);
            border: 2px solid #f8c471;
        }

        .card-selection-title {
            color: #f8c471;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .card-selection-grid {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
        }

        .selectable-card {
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            width: 45px;
            height: 65px;
            line-height: 65px;
            font-size: 16px;
        }

        .selectable-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .selectable-card.selected {
            border: 2px solid #ef4444;
            box-shadow: 0 0 10px #ef4444;
            transform: translateY(-8px);
        }

        .draw-actions {
            display: flex;
            gap: 10px;
        }

        .draw-button {
            padding: 8px 16px;
            font-weight: bold;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .draw-submit {
            background-color: #3b82f6;
            color: white;
        }

        .draw-submit:hover {
            background-color: #2563eb;
        }

        .draw-cancel {
            background-color: #6b7280;
            color: white;
        }

        .draw-cancel:hover {
            background-color: #4b5563;
        }

        .winner {
            animation: winner-glow 2s infinite;
            box-shadow: 0 0 25px gold !important;
            border: 3px solid gold !important;
            transform: scale(1.05);
            z-index: 10;
            background-color: rgba(0, 0, 0, 0.8) !important;
        }

        @keyframes winner-glow {
            0%, 100% { box-shadow: 0 0 25px gold; }
            50% { box-shadow: 0 0 40px #ffdd00; }
        }

        .winner-label {
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            background-color: gold;
            color: black;
            font-weight: bold;
            padding: 4px 12px;
            border-radius: 4px;
            animation: winner-bounce 1s infinite;
            z-index: 11;
            font-size: 16px;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }

        .winnings-label {
            animation: winnings-fade 1.5s infinite;
        }

        @keyframes winnings-fade {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }

        .hand-type {
            font-size: 12px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            margin-bottom: 5px;
            text-align: center;
        }

        .spectator-list {
            margin-top: 10px;
            padding: 5px;
            background-color: #f0f0f0;
            border-radius: 5px;
        }
            
        .spectator {
            color: #666;
            font-style: italic;
            margin-left: 5px;
        }

        .player-hand.winner {
            border: 2px solid gold;
            background-color: rgba(255, 215, 0, 0.1);
        }

        .player-hand.folded {
            opacity: 0.7;
        }

        .folded-card {
            opacity: 0.5;
        }

        #pot-container, #turn-container {
            margin: 10px 0;
            padding: 8px;
            background-color: #f0f8ff;
            border: 1px solid #b0c4de;
            border-radius: 4px;
            display: flex;
            justify-content: center;
        }
    </style>
</head>
<body>
    <div id="debug">Loading 5 Card Draw...</div>
    
    <div class="game-container">
        <div class="game-header">5 Card Draw Poker</div>
        
        <div class="table-area">
            <div class="table-center">
                <div class="pot">Pot: $0</div>
            </div>
            
            <div class="player-positions" id="playerPositions">
                <!-- Player spots will be generated here -->
            </div>
            
            <div class="game-status" id="gameStatus">
                Waiting for players...
            </div>
        </div>
    </div>

    <script>
        // Debug element for troubleshooting
        const debug = document.getElementById('debug');
        gameState = 0;
        
        let isSpectator = false;
        
        console.log('Game frame loaded');
        
        // Game elements
        const playerPositions = document.getElementById('playerPositions');
        const gameStatus = document.getElementById('gameStatus');

        // Add this as a global variable at the top of your script section
        let selectedCards = [];
        const DRAW_PHASE = 5; // Same as the DRAW constant in the Rust backend

        // Add this flag at the top of your script, near the other globals
        let drawingCompleted = false;

        // Add these globals at the top of your script
        const SHOWDOWN_PHASE = 7;
        let showdownData = null;

        // Update the window message listener to correctly handle game state updates
        window.addEventListener("message", function(event) {
            // Handle websocket messages forwarded from the parent window
            if (event.data.type === "websocket") {
                try {
                    const data = JSON.parse(event.data.data);
                    console.log("Game received websocket message:", data);
                    
                    // Process the combined state
                    if (data.lobbyInfo) {
                        // Handle lobby info if needed
                    }
                    
                    if (data.gameInfo) {
                        updateGameInfo(data.gameInfo);
                    }
                    
                    if (data.players) {
                        updatePlayerHands(data.players);
                    }
                    
                    // Handle specific action messages
                    if (data.action === "draw" && data.yourTurn === true) {
                        console.log("Drawing turn detected from direct message");
                        showCardSelectionUI();
                    }
                    
                } catch (e) {
                    console.error("Error handling websocket message:", e);
                }
            }
            
            // Handle commands from the lobby frame
            else if (event.data.type === "command") {
                console.log("Game received command:", event.data);
                
                if (event.data.command === "updateGameInfo") {
                    updateGameInfo(event.data.data);
                }
                
                if (event.data.command === "updatePlayers") {
                    console.log("updatePlayers command received:", event.data.data);
                    updatePlayers(event.data.data.players, event.data.data.spectators, event.data.data.gameActive);
                }
                
                if (event.data.command === "startGame") {
                    startGame(event.data.data);
                }
                
                if (event.data.command === "showdownHands") {
                    console.log("Showdown hands received:", event.data.data);
                    handleShowdownData(event.data.data);
                }
            }
        });

        // Update the updateGameInfo function to handle the currentPlayerTurn
        function updateGameInfo(data) {
            if (data && data.gameState !== undefined) {
                updateGameState(data.gameState);
            }
            
            if (data && data.currentPlayerTurn) {
                updatePlayerTurn(data.currentPlayerTurn);
                
                // Check if we need to show the drawing interface
                const currentPlayerName = localStorage.getItem('currentPlayerName');
                const isCurrentPlayerTurn = data.currentPlayerTurn === currentPlayerName;
                const isDraw = data.gameState === DRAW_PHASE;
                
                console.log("Game state: " + data.gameState + 
                        ", isDraw: " + isDraw + 
                        ", isCurrentTurn: " + isCurrentPlayerTurn + 
                        ", drawCompleted: " + drawingCompleted);
                
                if (isDraw && isCurrentPlayerTurn && !drawingCompleted) {
                    console.log("Drawing UI should display based on game state");
                    showCardSelectionUI();
                } else if (!isDraw || !isCurrentPlayerTurn) {
                    hideCardSelectionUI();
                }
            }
            
            // Update pot display if available
            if (data && data.pot !== undefined) {
                const potElement = document.querySelector('.pot');
                if (potElement) {
                    potElement.textContent = `Pot: $${data.pot}`;
                }
            }
            
            // Update other game state elements as needed
        }

        // Update player information
        function updatePlayers(players, spectators, gameActive) {
            // Check if the current player is a spectator
            const currentPlayerName = localStorage.getItem('currentPlayerName');
            if (spectators) {
                // Check if current player name is in the spectators list
                isSpectator = spectators.some(spectator => 
                    spectator.name === currentPlayerName
                );
            } else {
                isSpectator = false;
            }
            console.log("Is current player a spectator:", isSpectator);

            // Safety checks for undefined or non-array
            if (!players) {
                console.log('Warning: players data is undefined');
                return;
            }

            if (!Array.isArray(players)) {
                console.log('Warning: players is not an array, attempting to fix');
                if (typeof players === 'object') {
                    players = [players];
                } else {
                    return;
                }
            }
            
            console.log(`Updating ${players.length} players info`);

            if(!gameActive) {
                positionPlayers(players);
            }
            
            // Get all player spots in their current positions
            const playerSpots = document.querySelectorAll('.player-spot');
            console.log(`Found ${playerSpots.length} player spots to update`);
            
            // Map player names to their DOM elements
            const playerElements = {};
            playerSpots.forEach(spot => {
                const nameElement = spot.querySelector('.player-name');
                if (nameElement) {
                    playerElements[nameElement.textContent] = spot;
                }
            });
            
            // Update player information
            players.forEach(player => {
                const playerElement = playerElements[player.name];
                if (!playerElement) return;
                
                // Update chips/wallet
                const chipsElement = playerElement.querySelector('.player-chips');
                if (chipsElement) {
                    const walletAmount = player.chips || player.wallet || 1000;
                    chipsElement.textContent = `$${walletAmount}`;
                    
                    // Add visual effect when wallet changes
                    const currentAmount = parseInt(chipsElement.dataset.lastAmount || walletAmount);
                    if (currentAmount !== walletAmount) {
                        // Add a temporary class for animation
                        if (currentAmount > walletAmount) {
                            chipsElement.classList.add('wallet-decrease');
                            setTimeout(() => chipsElement.classList.remove('wallet-decrease'), 1000);
                        } else if (currentAmount < walletAmount) {
                            chipsElement.classList.add('wallet-increase');
                            setTimeout(() => chipsElement.classList.remove('wallet-increase'), 1000);
                        }
                        // Store new amount for next comparison
                        chipsElement.dataset.lastAmount = walletAmount;
                    }
                }
                
                // Update player state (folded, etc.)
                if (player.state !== undefined) {
                    if (player.state === 1) { // player::FOLDED = 1
                        playerElement.classList.add('player-folded');
                    } else {
                        playerElement.classList.remove('player-folded');
                    }
                }

                // Check for disconnected status
                if (player.disconnected) {
                    const playerElement = playerElements[player.name];
                    if (playerElement) {
                        // Add disconnected visual treatment
                        playerElement.classList.add('player-disconnected');
                        
                        // Add a disconnected indicator
                        const disconnectedIndicator = document.createElement('div');
                        disconnectedIndicator.className = 'disconnected-indicator';
                        disconnectedIndicator.textContent = 'DISCONNECTED';
                        playerElement.appendChild(disconnectedIndicator);
                        
                        // Also mark as folded for game mechanics
                        playerElement.classList.add('player-folded');
                    }
                }
            });
            
            // Update player hands if available
            const handsData = players
                .filter(player => player.hand && player.hand.length > 0)
                .map(player => ({
                    playerName: player.name,
                    hand: player.hand,
                    state: player.state
                }));

            console.log("handData:", handsData);
                
            if (handsData.length > 0) {
                updatePlayerHands(handsData, isSpectator);
            }
        }

        // Create a player spot with calculated position
        function createPlayerSpot(player, angle) {
            const playerSpot = document.createElement('div');
            playerSpot.className = 'player-spot';
            
            // Create HTML for player info
            playerSpot.innerHTML = `
                <div class="player-name">${player.name}</div>
                <div class="player-chips">$${player.chips || player.wallet || 1000}</div>
                <div class="player-cards">
                    <!-- Cards will be added dynamically only if player has cards -->
                </div>
            `;
            
            // Position based on angle
            const radius = 40; // % of container
            const radians = angle * (Math.PI / 180);
            const x = 50 + radius * Math.cos(radians);
            const y = 50 + radius * Math.sin(radians);
            
            playerSpot.style.left = `${x}%`;
            playerSpot.style.top = `${y}%`;
            playerSpot.style.transform = 'translate(-50%, -50%)';
            
            // Special styling for current player (bottom position)
            if (angle === 90) {
                playerSpot.style.bottom = '10px';
                playerSpot.style.left = '50%';
                playerSpot.style.top = 'auto';
                playerSpot.style.transform = 'translateX(-50%)';
            }
            
            // Add default face down cards if this is not an empty hand update
            const cardsContainer = playerSpot.querySelector('.player-cards');
            
            // Only add placeholder cards during the game
            const gameIsActive = gameStatus.textContent !== 'Waiting for players...';
            
            if (gameIsActive && (!player.hand || player.hand.length === 0)) {
                // Add placeholders for cards when in game but no cards received yet
                for (let i = 0; i < 5; i++) {
                    const card = document.createElement('div');
                    card.className = 'card facedown';
                    card.textContent = '?';
                    cardsContainer.appendChild(card);
                }
            }
            
            return playerSpot;
        }
        
        // Start the game - now responsible for positioning players
        function startGame(data) {
            console.log('Starting game');
            gameStatus.textContent = 'Game in progress...';
            
            // Log what we received
            console.log("Game start data received:", data);
            
            // Ensure data has valid players
            let players = [];
            if (data && Array.isArray(data.players)) {
                players = data.players;
            } else if (data && data.players) {
                // If data.players exists but is not an array
                console.log('Player data exists but may have wrong format');
                if (typeof data.players === 'object') {
                    players = [data.players];
                }
            }
            
            if (players.length === 0) {
                console.log('Warning: No player data available for game start');
                playerPositions.innerHTML = '';
                return;
            }
            
            // Position players around the table
            positionPlayers(players);
            
            // Update player information including hands
            updatePlayers(players);
        }

        // Calculate and create player positions
        function positionPlayers(players) {
            console.log(`Positioning ${players.length} players`);
            
            // Clear existing players
            playerPositions.innerHTML = '';
            
            // Get stored current player name
            const storedCurrentPlayerName = localStorage.getItem('currentPlayerName');
            console.log("Stored current player name: ", storedCurrentPlayerName);
            
            // Find current player index in original array
            let currentPlayerIndex = -1;
            if (storedCurrentPlayerName) {
                currentPlayerIndex = players.findIndex(p => p.name === storedCurrentPlayerName);
            }
            
            // If current player not found, use first player
            if (currentPlayerIndex === -1) {
                currentPlayerIndex = 0;
            }
            
            // Store player index mapping for later use with updatePlayerHands
            window.playerIndices = {};
            
            // Position players around the table, maintaining the original order
            const totalPlayers = players.length;
            const angleStep = 360 / totalPlayers;
            
            // Create and position all players, starting with the current player at bottom
            for (let i = 0; i < totalPlayers; i++) {
                // Calculate the player's position in the original array
                const playerIndex = (currentPlayerIndex + i) % totalPlayers;
                const player = players[playerIndex];
                
                // Store the mapping between player name and rotational index
                window.playerIndices[player.name] = i;
                
                // Calculate the angle, starting at 90 degrees (bottom)
                const angle = (90 + (i * angleStep)) % 360;
                
                // Create the player spot
                const playerSpot = createPlayerSpot(player, angle);
                
                // Add "current-player" class if this is the current player
                if (playerIndex === currentPlayerIndex) {
                    playerSpot.classList.add('current-player');
                }
                
                playerPositions.appendChild(playerSpot);
            }
        }

        // Initialize when the page loads
        window.onload = function() {
            console.log('Five Card Draw interface initialized');
            
            // Let the parent frame know we're ready
            window.parent.postMessage({
                type: 'gameFrameReady',
                gameType: '5 Card Draw'
            }, '*');
        };

        // Function to update player hands based on server data
        function updatePlayerHands(hands, isSpectator) {
            console.log("Updating player hands:", hands);
            
            if (!hands || !Array.isArray(hands) || hands.length === 0) {
                console.log("No hand data to update");
                return;
            }
            
            // Get current player name
            const currentPlayerName = localStorage.getItem('currentPlayerName');
            
            // Get all player spots in their current positions
            const playerSpots = document.querySelectorAll('.player-spot');
            
            // Map player names to their DOM elements
            const playerElements = {};
            playerSpots.forEach(spot => {
                const nameElement = spot.querySelector('.player-name');
                if (nameElement) {
                    playerElements[nameElement.textContent] = spot;
                }
            });
            
            // Update each player's cards
            hands.forEach(playerHand => {
                const playerName = playerHand.playerName;
                const hand = playerHand.hand || [];
                const state = playerHand.state;
                let isCurrentPlayer = (playerName === currentPlayerName);
                if (isSpectator) {
                    isCurrentPlayer = true;
                }
                console.log("is current player: ", isCurrentPlayer);
                
                // Find the DOM element for this player
                const playerElement = playerElements[playerName];
                if (!playerElement) {
                    console.log(`No DOM element found for player ${playerName}`);
                    return;
                }
                
                // Get the cards container for this player
                const cardsContainer = playerElement.querySelector('.player-cards');
                if (!cardsContainer) return;
                
                // Clear existing cards
                cardsContainer.innerHTML = '';
                
                // If player folded, show folded state
                if (state === 1) { // FOLDED = 1
                    const foldedDiv = document.createElement('div');
                    foldedDiv.className = 'folded-indicator';
                    foldedDiv.textContent = 'FOLDED';
                    cardsContainer.appendChild(foldedDiv);
                    playerElement.classList.add('player-folded');
                    return;
                }
                
                // Remove folded class if it exists
                playerElement.classList.remove('player-folded');
                
                // Skip if hand is empty - don't show any cards
                if (hand.length === 0) {
                    return;
                }
                
                // Create and add cards
                const maxCards = 5; // 5 Card Draw has 5 cards
                const cardCount = Math.min(hand.length, maxCards);
                
                for (let i = 0; i < cardCount; i++) {
                    const card = document.createElement('div');
                    
                    // Only add the dealing animation class for the current player
                    card.className = isCurrentPlayer ? 'card dealing' : 'card';
                    
                    // If this is the current player, show the actual card
                    // Otherwise keep it face down
                    if (isCurrentPlayer) {
                        console.log("Adding card for current player:", hand[i], typeof hand[i]);
                        card.textContent = cardToString(hand[i]);
                        card.dataset.cardValue = hand[i];
                        card.classList.add(getCardColor(hand[i]));
                        
                        // Remove the dealing animation class after the animation completes
                        setTimeout(() => {
                            card.classList.remove('dealing');
                        }, 300 + (i * 100));
                    } else {
                        card.textContent = '?';
                        card.classList.add('facedown');
                    }
                    
                    cardsContainer.appendChild(card);
                }
                
                // Fill remaining slots with empty placeholders if needed
                for (let i = cardCount; i < maxCards; i++) {
                    const emptyCard = document.createElement('div');
                    emptyCard.className = 'card card-placeholder';
                    cardsContainer.appendChild(emptyCard);
                }
            });
            
            // After cards are updated, check if the card selection UI should be shown
            const currentPlayerTurn = document.querySelector('.player-turn .player-name')?.textContent;
            const isCurrentTurn = currentPlayerName === currentPlayerTurn;
            
            // If it's the current player's turn and we're in draw phase, show selection UI
            if (isCurrentTurn && gameState === DRAW_PHASE) {
                // Add a slight delay to ensure the cards are rendered first
                setTimeout(() => {
                    showCardSelectionUI();
                }, 300);
            }
        }

        // Helper function to convert card value to string
        function cardToString(cardValue) {
            if (cardValue === undefined || cardValue === null) return '?';
            
            // Extract suit (0-3) and rank (0-12)
            const suit = Math.floor(cardValue / 13);
            const rank = cardValue % 13;
            
            // Rank symbols
            const ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
            
            // Suit symbols
            const suits = ['♠', '♥', '♦', '♣'];
            
            return ranks[rank] + suits[suit];
        }

        // Helper function to determine card color based on suit
        function getCardColor(cardValue) {
            if (cardValue === undefined || cardValue === null) return '';
            
            const suit = Math.floor(cardValue / 13);
            // Hearts and diamonds are red, spades and clubs are black
            return (suit === 1 || suit === 2) ? 'red-card' : 'black-card';
        }

        // Simplify the updateGameState function since updateGameInfo now handles drawing UI
        function updateGameState(newGameState) {
            console.log("Game state updated to:", newGameState);
            
            // If transitioning to JOINABLE (0), clear the game UI
            if (newGameState === 0 && gameState !== 0) {
                // Reset all game elements
                clearGameState();
            }
            
            // Update the global game state
            gameState = newGameState;
            
            // If the game state changes, reset the drawing completed flag
            if (gameState !== DRAW_PHASE) {
                drawingCompleted = false;
            }
            
            // Additional game state specific logic can be added here
            // but the drawing UI visibility is now handled in updateGameInfo
        }

        // Add this helper function to clean up game UI
        function clearGameState() {
            // Remove any active elements or highlights
            document.querySelectorAll('.player-turn').forEach(el => el.classList.remove('player-turn'));
            document.querySelectorAll('.winner').forEach(el => el.classList.remove('winner'));
            document.querySelectorAll('.winner-label').forEach(el => el.remove());
            document.querySelectorAll('.hand-type').forEach(el => el.remove());
            
            // Clear the game status
            gameStatus.textContent = 'Waiting for players to ready up...';
            
            // Clear any card selection UI if present
            hideCardSelectionUI();
            
            // Reset any game-specific flags
            drawingCompleted = false;
            selectedCards = [];
            showdownData = null;
        }

        // Update the showCardSelectionUI function to be more robust
        function showCardSelectionUI() {
            console.log("Attempting to show card selection UI");
            
            // Don't show the UI if the player has already completed drawing
            if (drawingCompleted) {
                console.log('Drawing already completed, not showing UI');
                return;
            }
            
            // Get the current player's cards
            const currentPlayerSpot = document.querySelector('.current-player');
            if (!currentPlayerSpot) {
                console.log("Could not find current player's spot");
                return;
            }
            
            // Remove any existing card selection UI
            const existingUI = document.getElementById('cardSelectionUI');
            if (existingUI) {
                existingUI.remove();
            }
            
            // Create card selection container
            const selectionUI = document.createElement('div');
            selectionUI.id = 'cardSelectionUI';
            selectionUI.className = 'card-selection-container';
            selectionUI.innerHTML = `
                <div class="card-selection-title">Select cards to exchange</div>
                <div class="card-selection-grid" id="cardSelectionGrid"></div>
                <div class="draw-actions">
                    <button class="draw-button draw-submit" onclick="submitCardExchange()">Exchange Selected Cards</button>
                    <button class="draw-button draw-cancel" onclick="submitCardExchange()">Keep All Cards</button>
                </div>
            `;
            document.querySelector('.table-area').appendChild(selectionUI);
            
            // Get cards from current player's hand and add them to the selection grid
            const cards = currentPlayerSpot.querySelectorAll('.card:not(.facedown):not(.card-placeholder)');
            const cardGrid = document.getElementById('cardSelectionGrid');
            
            selectedCards = []; // Reset selected cards array
            
            cards.forEach((card, index) => {
                const cardValue = card.dataset.cardValue;
                const selectableCard = document.createElement('div');
                selectableCard.className = `card selectable-card ${card.classList.contains('red-card') ? 'red-card' : 'black-card'}`;
                selectableCard.textContent = card.textContent;
                selectableCard.dataset.index = index;
                
                selectableCard.onclick = function() {
                    this.classList.toggle('selected');
                    const cardIndex = parseInt(this.dataset.index);
                    
                    if (this.classList.contains('selected')) {
                        if (!selectedCards.includes(cardIndex)) {
                            selectedCards.push(cardIndex);
                        }
                    } else {
                        selectedCards = selectedCards.filter(idx => idx !== cardIndex);
                    }
                    console.log("Selected cards:", selectedCards);
                };
                
                cardGrid.appendChild(selectableCard);
            });
            
            console.log("Card selection UI displayed");
        }

        // Function to hide card selection UI
        function hideCardSelectionUI() {
            const selectionUI = document.getElementById('cardSelectionUI');
            if (selectionUI) {
                selectionUI.remove();
            }
        }

        // Function to submit card exchange
        function submitCardExchange() {
            console.log('Submitting card exchange:', selectedCards);
            
            // Mark that this player has completed their drawing phase
            drawingCompleted = true;
            
            // Format the message exactly as lobby.html's sendToServer would
            const drawMessage = JSON.stringify({
                action: 'DrawCards',
                cardIndices: selectedCards
            });
            
            window.parent.postMessage({
                type: 'sendWebSocket',
                data: drawMessage
            }, '*');
            
            // Update game status
            gameStatus.textContent = 'Exchanging cards...';
            
            // Hide selection UI
            hideCardSelectionUI();
        }

        // Add this function to handle showdown updates
        function handleShowdownData(data) {
            console.log('Showdown data received:', data);
            showdownData = data.data;
            
            // Create and display the showdown UI
            displayShowdownResults();
            
            // If a winner message was provided, display it
            if (data.winnerMessage) {
                const gameStatus = document.getElementById('gameStatus');
                gameStatus.textContent = data.winnerMessage;
            }
        }

        // Function to display showdown results
        function displayShowdownResults() {
            if (!showdownData || !showdownData.hands || !showdownData.hands.length) {
                console.error("Invalid showdown data:", showdownData);
                return;
            }
            
            console.log("Displaying showdown results:", showdownData);
            
            // Now reveal all cards and highlight winners
            const playerSpots = document.querySelectorAll('.player-spot');
            
            playerSpots.forEach(spot => {
                const nameElement = spot.querySelector('.player-name');
                if (!nameElement) return;
                
                const playerName = nameElement.textContent;
                const playerData = showdownData.hands.find(h => h.playerName === playerName);
                
                if (!playerData) return;
                
                // Get the cards container
                const cardsContainer = spot.querySelector('.player-cards');
                if (!cardsContainer) return;
                
                // Clear existing cards
                cardsContainer.innerHTML = '';
                
                // Display all cards face up
                if (playerData.hand && playerData.hand.length) {
                    playerData.hand.forEach(cardValue => {
                        const card = document.createElement('div');
                        card.className = `card ${getCardColor(cardValue)}`;
                        card.textContent = cardToString(cardValue);
                        cardsContainer.appendChild(card);
                    });
                }
                
                // Check if this player is a winner
                if (playerData.winner) {
                    // Add winner class to highlight the entire player spot
                    spot.classList.add('winner');
                    
                    // Make the player name stand out
                    nameElement.style.color = 'gold';
                    nameElement.style.fontWeight = 'bold';
                    nameElement.textContent = `★ ${playerName} ★`;
                    
                    // Add winner indicator
                    const winnerLabel = document.createElement('div');
                    winnerLabel.className = 'winner-label';
                    winnerLabel.textContent = 'WINNER!';
                    spot.appendChild(winnerLabel);
                    
                    // Show pot amount won
                    if (showdownData.pot) {
                        const winningsLabel = document.createElement('div');
                        winningsLabel.className = 'winnings-label';
                        winningsLabel.textContent = `Won $${showdownData.pot}`;
                        winningsLabel.style.color = '#4ade80';
                        winningsLabel.style.fontWeight = 'bold';
                        winningsLabel.style.marginTop = '5px';
                        spot.appendChild(winningsLabel);
                    }
                }
            });
            
            // Update game status with the winner message
            if (showdownData.winnerMessage) {
                gameStatus.textContent = showdownData.winnerMessage;
            } else {
                gameStatus.textContent = 'Showdown - Winner determined!';
            }
        }

        // Add this function to show the drawing interface only when it's the player's turn
        function showDrawingInterface() {
            const drawingContainer = document.getElementById('drawingContainer');
            if (drawingContainer) {
                drawingContainer.style.display = 'block';
            }
        }

        // Add this function to keep track of whose turn it is
        function updatePlayerTurn(playerName) {
            // Remove 'player-turn' class from all players
            document.querySelectorAll('.player-turn').forEach(el => el.classList.remove('player-turn'));
            
            // Find the player element by name and add the 'player-turn' class
            const playerSpots = document.querySelectorAll('.player-spot');
            for (const spot of playerSpots) {
                const nameElement = spot.querySelector('.player-name');
                if (nameElement && nameElement.textContent === playerName) {
                    spot.classList.add('player-turn');
                    break;
                }
            }
            
            // Update game status to show whose turn it is
            const gameStatus = document.getElementById('gameStatus');
            if (gameStatus) {
                // Only update if the status isn't showing something more important
                if (!gameStatus.textContent.includes('Winner') && 
                    !gameStatus.textContent.includes('Showdown') &&
                    !gameStatus.textContent.includes('Waiting for players')) {
                    gameStatus.textContent = `${playerName}'s turn`;
                }
            }
            
            // Set a global variable for easy access
            window.currentTurnPlayer = playerName;
        }

        // When player confirms card selection, send to server through the iframe messaging system
        function submitCardSelection() {
            if (selectedCards.length > 0) {
                console.log("Submitting card selection:", selectedCards);
                
                // Create message for server
                const drawMessage = {
                    action: "DrawCards",
                    data: {
                        cardIndices: selectedCards
                    }
                };
                
                // Send using the existing postMessage system to parent
                window.parent.postMessage({
                    type: 'sendWebSocket',
                    data: JSON.stringify(drawMessage)
                }, '*');
                
                // Set flag to prevent multiple draws
                drawingCompleted = true;
                
                // Hide the selection UI
                hideCardSelectionUI();
            } else {
                // Player chose not to exchange any cards
                const drawMessage = {
                    action: "DrawCards",
                    data: {
                        cardIndices: []
                    }
                };
                
                window.parent.postMessage({
                    type: 'sendWebSocket',
                    data: JSON.stringify(drawMessage)
                }, '*');
                
                drawingCompleted = true;
                hideCardSelectionUI();
            }
        }

        // Add spectator UI elements similar to the others

        // Update the player hands function
        // function updatePlayerHands(playersData) {
        //     console.log("Updating player hands:", playersData);
        //     const container = document.getElementById("players-hands");
        //     container.innerHTML = "";
            
        //     playersData.forEach(playerData => {
        //         const playerDiv = document.createElement("div");
        //         playerDiv.className = "player-hand";
                
        //         // Add player name
        //         const nameElement = document.createElement("div");
        //         nameElement.className = "player-name";
        //         nameElement.textContent = playerData.playerName;
                
        //         // Add player state if available
        //         if (playerData.state) {
        //             if (playerData.state === 1) {
        //                 nameElement.textContent += " (Folded)";
        //                 playerDiv.classList.add("folded");
        //             } else if (playerData.state === 6) {
        //                 nameElement.textContent += " (All-In)";
        //             }
        //         }
                
        //         playerDiv.appendChild(nameElement);
                
        //         // Create cards container
        //         const cardsDiv = document.createElement("div");
        //         cardsDiv.className = "cards";
                
        //         // In Five Card Draw, only show current player's cards until showdown
        //         if (playerData.playerName === username || playerData.showCards) {
        //             // Show all cards for the current player or when cards should be shown
        //             playerData.hand.forEach(card => {
        //                 cardsDiv.appendChild(createCardElement(card));
        //             });
        //         } else {
        //             // For other players, show face down cards
        //             for (let i = 0; i < 5; i++) {
        //                 cardsDiv.appendChild(createCardElement(-1)); // -1 represents face down
        //             }
        //         }
                
        //         playerDiv.appendChild(cardsDiv);
        //         container.appendChild(playerDiv);
        //     });
        // }

        // Implement showdown display function for five card draw
        function displayShowdownHands(hands) {
            const container = document.getElementById("players-hands");
            container.innerHTML = "";
            
            hands.forEach(playerData => {
                const playerDiv = document.createElement("div");
                playerDiv.className = "player-hand";
                
                // Highlight winners
                if (playerData.winner) {
                    playerDiv.classList.add("winner");
                }
                
                // Create player name with hand type
                const nameElement = document.createElement("div");
                nameElement.className = "player-name";
                
                let nameText = playerData.playerName;
                if (playerData.handName) {
                    nameText += " - " + playerData.handName;
                }
                
                if (playerData.state === 1) {
                    nameText += " (Folded)";
                    playerDiv.classList.add("folded");
                }
                
                nameElement.textContent = nameText;
                playerDiv.appendChild(nameElement);
                
                // Create cards container - all cards visible at showdown
                const cardsDiv = document.createElement("div");
                cardsDiv.className = "cards";
                
                if (playerData.hand && playerData.state !== 1) {
                    playerData.hand.forEach(card => {
                        cardsDiv.appendChild(createCardElement(card));
                    });
                } else if (playerData.state === 1 && playerData.hand) {
                    // Show folded player's cards at showdown with visual indication
                    playerData.hand.forEach(card => {
                        const cardEl = createCardElement(card);
                        cardEl.classList.add("folded-card");
                        cardsDiv.appendChild(cardEl);
                    });
                }
                
                playerDiv.appendChild(cardsDiv);
                container.appendChild(playerDiv);
            });
        }

        // Add this function to each game HTML file if not already present
        function createCardElement(cardValue) {
            const cardElement = document.createElement("div");
            cardElement.className = "card";
            
            if (cardValue === -1 || cardValue > 52) {
                // Face down card
                cardElement.classList.add("card-back");
                cardElement.textContent = "";
            } else {
                // Face up card
                const rank = cardValue % 13;
                const suit = Math.floor(cardValue / 13);
                
                // Determine rank text
                let rankText;
                if (rank === 0) {
                    rankText = "A";
                } else if (rank === 10) {
                    rankText = "J";
                } else if (rank === 11) {
                    rankText = "Q";
                } else if (rank === 12) {
                    rankText = "K";
                } else {
                    rankText = (rank + 1).toString();
                }
                
                // Determine suit symbol
                let suitSymbol;
                let suitClass;
                if (suit === 0) {
                    suitSymbol = "♥";
                    suitClass = "hearts";
                } else if (suit === 1) {
                    suitSymbol = "♦";
                    suitClass = "diamonds";
                } else if (suit === 2) {
                    suitSymbol = "♠";
                    suitClass = "spades";
                } else {
                    suitSymbol = "♣";
                    suitClass = "clubs";
                }
                
                cardElement.classList.add(suitClass);
                cardElement.innerHTML = `<div class="card-value">${rankText}</div><div class="card-suit">${suitSymbol}</div>`;
            }
            
            return cardElement;
        }
    </script>
</body>
</html>